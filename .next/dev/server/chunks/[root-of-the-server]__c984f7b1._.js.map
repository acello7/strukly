{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/kimoc/OneDrive/Desktop/KolosalAProject/strukly/lib/firebase.ts"],"sourcesContent":["import { initializeApp, getApps, getApp } from \"firebase/app\";\r\nimport { getAuth } from \"firebase/auth\";\r\nimport { getFirestore } from \"firebase/firestore\";\r\nimport { getStorage } from \"firebase/storage\";\r\nimport { getAnalytics, isSupported } from \"firebase/analytics\";\r\n\r\n// Ensure required NEXT_PUBLIC_FIREBASE_* env vars are present so the SDK\r\n// doesn't fail with a vague \"configuration-not-found\" error at runtime.\r\nconst requiredFirebaseEnv = [\r\n  'NEXT_PUBLIC_FIREBASE_API_KEY',\r\n  'NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN',\r\n  'NEXT_PUBLIC_FIREBASE_DATABASE_URL',\r\n  'NEXT_PUBLIC_FIREBASE_PROJECT_ID',\r\n  'NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET',\r\n  'NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID',\r\n  'NEXT_PUBLIC_FIREBASE_APP_ID',\r\n  'NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID',\r\n];\r\n\r\n// Only validate env vars on the server during module evaluation. In the\r\n// browser `process.env` may not be available in the same way and Next's\r\n// runtime will inline NEXT_PUBLIC_* values at build, so checking here can\r\n// produce false positives and noisy console errors in development.\r\nlet missing: string[] = []\r\nif (typeof window === 'undefined') {\r\n  missing = requiredFirebaseEnv.filter((k) => !process.env[k])\r\n  if (missing.length > 0) {\r\n    const msg = `Missing required Firebase env vars: ${missing.join(', ')}.\\n` +\r\n      `Add them to your local env (e.g. .env.local) or your hosting environment. ` +\r\n      `Example keys: ${requiredFirebaseEnv.join(', ')}`;\r\n    // Throw on the server so the developer sees a clear error immediately.\r\n    throw new Error(msg)\r\n  }\r\n} else {\r\n  // In client bundles avoid logging an error here â€” instead rely on server-side\r\n  // diagnostics endpoint (`/debug`) and Firebase SDK errors which are more\r\n  // reliable for runtime failures. Keep `missing` empty for diagnostics.\r\n  missing = []\r\n}\r\n\r\nconst firebaseConfig = {\r\n  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\r\n  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\r\n  databaseURL: process.env.NEXT_PUBLIC_FIREBASE_DATABASE_URL,\r\n  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\r\n  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\r\n  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\r\n  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,\r\n  measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID,\r\n};\r\n\r\n// Initialize Firebase\r\nconst app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApp();\r\n\r\n// Initialize services\r\nexport const auth = getAuth(app);\r\nexport const db = getFirestore(app);\r\nexport const storage = getStorage(app);\r\n\r\n// Initialize Analytics only on client side\r\nexport const analytics = typeof window !== \"undefined\" ? isSupported().then(yes => yes ? getAnalytics(app) : null) : null;\r\n\r\nexport default app;\r\n\r\n// Diagnostic helper to inspect the initialized Firebase options at runtime.\r\nexport function getFirebaseDiagnostics() {\r\n  try {\r\n    const options = app.options || null;\r\n    return {\r\n      initialized: !!options,\r\n      options,\r\n      missingEnv: missing,\r\n    };\r\n  } catch (e) {\r\n    return { initialized: false, options: null, missingEnv: missing };\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;AAEA,yEAAyE;AACzE,wEAAwE;AACxE,MAAM,sBAAsB;IAC1B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,wEAAwE;AACxE,wEAAwE;AACxE,0EAA0E;AAC1E,mEAAmE;AACnE,IAAI,UAAoB,EAAE;AAC1B,wCAAmC;IACjC,UAAU,oBAAoB,MAAM,CAAC,CAAC,IAAM,CAAC,QAAQ,GAAG,CAAC,EAAE;IAC3D,IAAI,QAAQ,MAAM,GAAG,GAAG;QACtB,MAAM,MAAM,CAAC,oCAAoC,EAAE,QAAQ,IAAI,CAAC,MAAM,GAAG,CAAC,GACxE,CAAC,0EAA0E,CAAC,GAC5E,CAAC,cAAc,EAAE,oBAAoB,IAAI,CAAC,OAAO;QACnD,uEAAuE;QACvE,MAAM,IAAI,MAAM;IAClB;AACF,OAAO;IACL,8EAA8E;IAC9E,yEAAyE;IACzE,uEAAuE;IACvE,UAAU,EAAE;AACd;AAEA,MAAM,iBAAiB;IACrB,MAAM;IACN,UAAU;IACV,WAAW;IACX,SAAS;IACT,aAAa;IACb,iBAAiB;IACjB,KAAK;IACL,aAAa;AACf;AAEA,sBAAsB;AACtB,MAAM,MAAM,IAAA,6KAAO,IAAG,MAAM,KAAK,IAAI,IAAA,mLAAa,EAAC,kBAAkB,IAAA,4KAAM;AAGpE,MAAM,OAAO,IAAA,+KAAO,EAAC;AACrB,MAAM,KAAK,IAAA,mLAAY,EAAC;AACxB,MAAM,UAAU,IAAA,oMAAU,EAAC;AAG3B,MAAM,YAAY,sCAAgC,0BAA4D;uCAEtG;AAGR,SAAS;IACd,IAAI;QACF,MAAM,UAAU,IAAI,OAAO,IAAI;QAC/B,OAAO;YACL,aAAa,CAAC,CAAC;YACf;YACA,YAAY;QACd;IACF,EAAE,OAAO,GAAG;QACV,OAAO;YAAE,aAAa;YAAO,SAAS;YAAM,YAAY;QAAQ;IAClE;AACF"}},
    {"offset": {"line": 231, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/kimoc/OneDrive/Desktop/KolosalAProject/strukly/app/debug/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\r\nimport { getFirebaseDiagnostics } from '@/lib/firebase'\r\n\r\nexport async function GET() {\r\n  try {\r\n    const diag = getFirebaseDiagnostics()\r\n\r\n    // Mask sensitive env values but show presence and length\r\n    const mask = (v: any) => {\r\n      if (v == null) return null\r\n      const s = String(v)\r\n      if (s.length <= 6) return '******'\r\n      return s.slice(0, 3) + '...' + s.slice(-3)\r\n    }\r\n\r\n    const envs = {\r\n      NEXT_PUBLIC_FIREBASE_API_KEY: mask(process.env.NEXT_PUBLIC_FIREBASE_API_KEY),\r\n      NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN: mask(process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN),\r\n      NEXT_PUBLIC_FIREBASE_DATABASE_URL: mask(process.env.NEXT_PUBLIC_FIREBASE_DATABASE_URL),\r\n      NEXT_PUBLIC_FIREBASE_PROJECT_ID: mask(process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID),\r\n      NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET: mask(process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET),\r\n      NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID: mask(process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID),\r\n      NEXT_PUBLIC_FIREBASE_APP_ID: mask(process.env.NEXT_PUBLIC_FIREBASE_APP_ID),\r\n      NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID: mask(process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID),\r\n    }\r\n\r\n    return NextResponse.json({ ok: true, diag, envs })\r\n  } catch (err: any) {\r\n    return NextResponse.json({ ok: false, error: String(err) }, { status: 500 })\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,OAAO,IAAA,2IAAsB;QAEnC,yDAAyD;QACzD,MAAM,OAAO,CAAC;YACZ,IAAI,KAAK,MAAM,OAAO;YACtB,MAAM,IAAI,OAAO;YACjB,IAAI,EAAE,MAAM,IAAI,GAAG,OAAO;YAC1B,OAAO,EAAE,KAAK,CAAC,GAAG,KAAK,QAAQ,EAAE,KAAK,CAAC,CAAC;QAC1C;QAEA,MAAM,OAAO;YACX,8BAA8B;YAC9B,kCAAkC;YAClC,mCAAmC;YACnC,iCAAiC;YACjC,qCAAqC;YACrC,0CAA0C;YAC1C,6BAA6B;YAC7B,qCAAqC;QACvC;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,IAAI;YAAM;YAAM;QAAK;IAClD,EAAE,OAAO,KAAU;QACjB,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,IAAI;YAAO,OAAO,OAAO;QAAK,GAAG;YAAE,QAAQ;QAAI;IAC5E;AACF"}}]
}